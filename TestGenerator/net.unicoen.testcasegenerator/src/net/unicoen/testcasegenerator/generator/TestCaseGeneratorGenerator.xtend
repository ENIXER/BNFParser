/*
 * generated by Xtext
 */
package net.unicoen.testcasegenerator.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import net.unicoen.testcasegenerator.testCaseGenerator.File
import net.unicoen.testcasegenerator.testCaseGenerator.TestCase
import net.unicoen.testcasegenerator.testCaseGenerator.NodeDeclaration
import net.unicoen.testcasegenerator.testCaseGenerator.NodeValue
import net.unicoen.testcasegenerator.testCaseGenerator.NodeArchitecture
import net.unicoen.testcasegenerator.testCaseGenerator.List
import net.unicoen.testcasegenerator.testCaseGenerator.ChildDeclaration
import java.util.ArrayDeque
import java.lang.reflect.ParameterizedType

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class TestCaseGeneratorGenerator implements IGenerator {

	private val stack = new ArrayDeque<Integer>
	private var nodeCount = 0

	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		resource.allContents.filter(File).forEach [
			fsa.generateFile(it.name.name + ".xtend", it.compile)
		]
	}

	private def compile(File file) '''
		«generateImports»
		
		class «file.name.name» extends MapperTest {
			val mapper = new «file.target.name»(true)
			
			«FOR it : file.cases»
				«it.compile»
			«ENDFOR»
		}
	'''

	private def compile(TestCase testCase) {
		val ret = '''
			@Test
			def void «testCase.name»() {
				val actual = mapper.parse("«testCase.code.body.name.replace("\"", "\\\"")»")
				
				«testCase.node.compile»
				node«stack.pop».evaluate(actual)
			}
			
		'''
		stack.clear
		nodeCount = 0
		ret
	}

	private def compile(NodeDeclaration node) {
		node.value.compile(null)
	}

	private def Object compile(NodeValue value, Class<?> castType) {
		if (value.arch != null) {
			value.arch.compile
		} else if (value.list != null) {
			value.list.compile(castType)
		} else {
			value.literal.compile
		}
	}

	private def compile(NodeArchitecture arch) {
		val cls = Class.forName("net.unicoen.node." + arch.nodeType)
		val ret1 = '''
			«FOR child : arch.children»
				«child.compile(cls)»
			«ENDFOR»
		'''

		val localStack = new ArrayDeque<Integer>
		for (child : arch.children) {
			localStack.push(stack.pop)
		}

		nodeCount++

		val ret2 = '''
			val node«nodeCount» = new «arch.nodeType»
			«FOR child : arch.children»
				node«nodeCount».«child.fieldName» = node«localStack.pop»
			«ENDFOR»
		'''
		stack.push(nodeCount)
		'''
			«ret1»
			«ret2»
			
		'''
	}

	private def compile(ChildDeclaration child, Class<?> nodeType) {
		val field = nodeType.getField(child.fieldName)
		child.value.compile(
			if (field.genericType instanceof ParameterizedType)
				(field.genericType as ParameterizedType).actualTypeArguments.get(0) as Class<?>
			else
				null)

	}

	private def compile(List list, Class<?> castType) {
		val ret1 = '''
			«FOR v : list.value»
				«v.compile(null)»
			«ENDFOR»
		'''
		val localStack = new ArrayDeque<Integer>
		for (v : list.value) {
			localStack.push(stack.pop)
		}
		nodeCount++

		val ret2 = '''
		val node«nodeCount» = #[«FOR v : list.value»node«localStack.pop»«if (v.arch != null &&
			v.arch.nodeType != castType.simpleName) {
			" as " + castType.simpleName
		} else {
			""
		}»«IF list.value.findLast[true] != v», «ENDIF»«ENDFOR»]'''
		stack.push(nodeCount)
		'''
			«ret1»
			«ret2»
			
		'''
	}

	private def compile(String literal) {
		nodeCount++
		val ret = '''
			val node«nodeCount» = «literal»
			
		'''
		stack.push(nodeCount)
		ret
	}

	private def generateImports() '''
		package net.unicoen.mapper
		
		import net.unicoen.node.*
		import org.junit.Test
	'''
}

/*
 * generated by Xtext
 */
package com.waseda.enixer.exbnf.generator

import com.waseda.enixer.exbnf.exBNF.ElementWithDollar
import com.waseda.enixer.exbnf.exBNF.Grammar
import com.waseda.enixer.exbnf.exBNF.LexerRule
import com.waseda.enixer.exbnf.exBNF.ParserRule
import com.waseda.enixer.exbnf.exBNF.RuleRef
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import java.lang.reflect.Type
import java.lang.reflect.ParameterizedType
import net.unicoen.node.UniNode
import com.waseda.enixer.exbnf.exBNF.Atom
import com.waseda.enixer.exbnf.exBNF.Terminal

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ExBNFGenerator implements IGenerator {
	private String _grammarName
	private int _nonTerminalId
	private int _terminalId

	override def doGenerate(Resource resource, IFileSystemAccess fsa) {
		val g4Generator = new ANTLRGrammarGenerator(fsa)
		resource.allContents.toIterable.filter(Grammar).forEach [
			_grammarName = it.name.toCamelCase
			g4Generator.generate(_grammarName, it);
			fsa.generateFile(_grammarName + "Mapper.xtend", it.generateMapper)
			fsa.generateFile(_grammarName + "MapperTest.xtend", it.generateMapperTestTemplate)
		]
	}

	def generateMapperTestTemplate(Grammar g) '''package net.unicoen.mapper

import org.junit.Test
import static org.hamcrest.Matchers.*
import static org.junit.Assert.*

class «_grammarName»MapperTest {
	val mapper = new «_grammarName»Mapper(true)

	@Test
	def «_grammarName»Test(){
		
	}

}
	'''

	def generateImports() '''package net.unicoen.mapper

import java.io.FileInputStream
import java.util.ArrayList
import org.antlr.v4.runtime.ANTLRInputStream
import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.RuleContext
import org.antlr.v4.runtime.tree.ParseTree
import org.antlr.v4.runtime.tree.RuleNode
import org.antlr.v4.runtime.tree.TerminalNode
import net.unicoen.parser.«_grammarName»Lexer
import net.unicoen.parser.«_grammarName»Parser
import net.unicoen.parser.«_grammarName»BaseVisitor
import net.unicoen.node.*
'''

	def generateMapper(Grammar g) {
		val sb = new StringBuilder
		sb.nl(generateImports)
		_nonTerminalId = 0
		_terminalId = 0

		sb.nl('''class «_grammarName»Mapper extends «_grammarName»BaseVisitor<Object> {
	var _isDebugMode = false

	new(boolean isDebugMode) {
		_isDebugMode = isDebugMode
	}

	def parseFile(String path) {
		val inputStream = new FileInputStream(path)
		try {
			parseCore(new ANTLRInputStream(inputStream))
		} finally {
			inputStream.close
		}
	}

	def parse(String code) {
		parseCore(new ANTLRInputStream(code))
	}

	def parseCore(CharStream chars) {
		val lexer = new «_grammarName»Lexer(chars)
		val tokens = new CommonTokenStream(lexer)
		val parser = new «_grammarName»Parser(tokens)
«IF g.rules.size > 0»		val tree = parser.«IF g.root != null»«g.root.root.name»«ELSE»«g.rules.get(0).name»«ENDIF»
		tree.visit
«ENDIF»	}

	override public visitChildren(RuleNode node) {
		val n = node.childCount;
		(0 ..< n).fold(defaultResult) [ acc, i |
			if (!node.shouldVisitNextChild(acc)) {
				acc
			} else {
				val c = node.getChild(i);
				val childResult = c.visit;
				acc.aggregateResult(childResult);
			}
		]
	}

	override public visit(ParseTree tree) {
		if (_isDebugMode) {
			if (!(tree instanceof ParserRuleContext)) {
				return visitTerminal(tree as TerminalNode)
			}
			val ruleName = «_grammarName»Parser.ruleNames.get((tree as ParserRuleContext).ruleIndex)
			println("*** visit" + ruleName + " ***")
			println(tree.text)
			val ret = tree.accept(this)
			println("returned: " + ret)
			ret
		} else {
			tree.accept(this)
		}
	}''')
		sb.nl
		g.rules.forEach [
			if (it.type != null) {
				if (it.type.name.endsWith("Literal")) {
					sb.append(it.makeLiteralMethod)
				} else {
					sb.append(it.makeVisitMethod)
				}
			} else {
				_nonTerminalId += it.eAllContents.filter(RuleRef).size
				_terminalId += it.eAllContents.filter(Terminal).size
			}
		]
		sb.nl('}')
		sb.toString
	}

	def toCamelCase(String str) {
		Character.toUpperCase(str.charAt(0)) + str.substring(1)
	}

	def dispatch makeVisitMethod(ParserRule r) {
		val sb = new StringBuilder
		val ruleName = r.name.toCamelCase
		sb.nl('''	override public visit«ruleName»(«_grammarName»Parser.«ruleName»Context ctx) {''')
		val typeName = r.type.name
		if (typeName.startsWith("Uni")) {
			val packagePrefix = UniNode.package.name + '.'
			sb.append(r.makeMethodBody(Class.forName(packagePrefix + typeName)))
		} else if (typeName.startsWith("List")) {
			_nonTerminalId += r.eAllContents.size
			val itemClassName = typeName.substring(typeName.indexOf('<') + 1, typeName.indexOf('>'))
			sb.append(r.makeListMethodBody(itemClassName))
		} else if (typeName.equals("String")) {
			sb.append(r.makeStringMethodBody)
		} else {
			die("Unknown Class Name: " + typeName)
		}
		sb.nl('''	}''')
		sb.nl
		sb
	}

	def makeCaseStatement(ElementWithDollar obj, String fieldTypeName, String fieldName, StringBuilder sb) {
		if (!(obj.body.body instanceof Atom)) {
			die("Internal error: " + obj.body.body)
		}
		val rule = obj.eAllContents.toList.filter(RuleRef).head
		if (rule != null) {
			val ruleName = rule.reference.name.toCamelCase
			if (fieldTypeName.contains("List")) {
				sb.nl('''					case «_nonTerminalId»: {''')
				val refType = obj.referenceReturnType
				if (refType == null) {
					die("Rule " + ruleName + " does not have return type.")
				}
				if (refType.contains("List")) {
					sb.nl('''						if (ret.«fieldName» == null) {''')
					sb.nl('''							ret.«fieldName» = it.visit as «fieldTypeName»''')
					sb.nl('''						} else {''')
					sb.nl('''							ret.«fieldName» += it.visit as «fieldTypeName»''')
					sb.nl('''						}''')
				} else {
					sb.nl('''						if (ret.«fieldName» == null) {''')
					sb.nl('''							ret.«fieldName» = new ArrayList<«refType»>''')
					sb.nl('''						}''')
					sb.nl('''						ret.«fieldName» += it.visit as «fieldTypeName»''')
				}
				sb.nl('''					}''')
			} else {
				sb.nl('''					case «_nonTerminalId»:''')
				sb.nl('''						ret.«fieldName» = it.visit as «fieldTypeName»''')
			}
			return
		}
		die("Unreach")
	}

	def makeMethodBody(ParserRule r, Class<?> clazz) {
		val sb = new StringBuilder
		sb.nl('''		val ret = new «r.type.name»''')
		sb.nl('''		ctx.children.forEach [''')
		sb.nl('''			if (it instanceof RuleContext) {''')
		sb.nl('''				switch (it as RuleContext).invokingState {''')
		var list = r.eAllContents.toIterable.filter(ElementWithDollar)
		list.forEach [
			if (it.op == null) {
				it.countId
				return
			}
			if (it.op.equals("__merge")) {
				if (!r.type.name.equals(it.referenceReturnType)) {
					die("Expected return type: " + r.type.name + " actual type: " + it.referenceReturnType)
				}
				val ruleName = it.eAllContents.toIterable.filter(RuleRef).get(0).reference.name.toCamelCase
				sb.nl('''				case «_nonTerminalId»: {''')
				sb.nl('''					val child = it.visit as «r.type.name»''')
				sb.nl('''					ret.merge(child)''')
				sb.nl('''				}''')
				it.countId
				return
			}
			try {
				val field = clazz.getField(it.op)
				val fieldTypeName = field.genericType.typeName
				it.makeCaseStatement(fieldTypeName, it.op, sb)
				it.countId
			} catch (NoSuchFieldException e) {
				die("No such Field: " + it.op)
			}
		]
		sb.nl('''				}''')
		sb.nl('''			}''')
		sb.nl('''		]''')
		sb.nl('''		ret''')
		sb.toString
	}

	def getReferenceReturnType(ElementWithDollar r) {
		if (r.body.body instanceof Atom) {
			val atom = r.body.body as Atom
			if (atom.body instanceof RuleRef) {
				val ref = atom.body as RuleRef
				if (ref.reference.type != null) {
					ref.reference.type.name
				}
			}
		}
	}

	def getTypeName(Type type) {
		switch type {
			Class<?>:
				return type.name
			ParameterizedType: {
				val sb = new StringBuilder
				sb.append(type.typeName).append('<')
				var isFirst = true
				for (Type arg : type.actualTypeArguments) {
					if (!isFirst) {
						sb.append(',')
					}
					sb.append(arg.typeName)
				}
				sb.append('>')
				return sb.toString
			}
			default:
				die("Unknown type:" + type.toString)
		}
	}

	def makeListMethodBody(ParserRule r, String itemClassName) {
		val sb = new StringBuilder
		sb.nl('''		val list = new ArrayList<«itemClassName»>
		if (ctx.children != null) {
			ctx.children.forEach [
				list += it.visit as «itemClassName»
			]
		}
		list''')
		sb.toString
	}

	def dispatch makeVisitMethod(LexerRule r) {
		r.type.name
	}

	def makeStringMethodBody(ParserRule r) {
		val sb = new StringBuilder
		sb.nl('''		ctx.text''')
		sb.toString
	}

	def dispatch makeLiteralMethod(ParserRule r) {
		val sb = new StringBuilder
		val methodName = "visit" + r.name.toCamelCase
		sb.nl('''	override public «methodName»(«_grammarName»Parser.«r.name.toCamelCase»Context ctx) {''')
		sb.nl('''		throw new RuntimeException("Unimplemented Method: «methodName»")''')
		sb.nl('''	}''')
		sb.nl
		sb.toString
	}

	def dispatch makeLiteralMethod(LexerRule r) {
		r.makeVisitMethod
	}

	def die(String message) {
		throw new RuntimeException(message)
	}

	def nl(StringBuilder sb, CharSequence contents) {
		sb.append(contents)
		sb.nl
	}

	def nl(StringBuilder sb) {
		sb.append(System.getProperty("line.separator"))
	}

	def countId(ElementWithDollar e) {
		if (e.body.body instanceof Atom) {
			val atom = e.body.body as Atom
			if (atom.body instanceof RuleRef) {
				_nonTerminalId++
			} else if (atom.body instanceof Terminal) {
				_terminalId++
			}
		}
	}

}

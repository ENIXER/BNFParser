/*
 * generated by Xtext
 */
package com.waseda.enixer.exbnf.generator

import com.waseda.enixer.exbnf.exBNF.ElementWithDollar
import com.waseda.enixer.exbnf.exBNF.Grammar
import com.waseda.enixer.exbnf.exBNF.LexerRule
import com.waseda.enixer.exbnf.exBNF.ParserRule
import com.waseda.enixer.exbnf.exBNF.RuleRef
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator
import java.lang.reflect.Type
import java.lang.reflect.ParameterizedType
import net.unicoen.node.UniNode

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ExBNFGenerator implements IGenerator {
	val nl = System.getProperty("line.separator")
	val packagePrefix = UniNode.package.name + '.'
	private String _name

	override def doGenerate(Resource resource, IFileSystemAccess fsa) {
		val g4Generator = new ANTLRGrammarGenerator(fsa)
		resource.allContents.toIterable.filter(Grammar).forEach [
			_name = it.name.toCamelCase
			g4Generator.generate(_name, it);
			fsa.generateFile(_name + "Mapper.xtend", it.generateMapper)
			fsa.generateFile(_name + "MapperTest.xtend", it.generateMapperTestTemplate)
		]
	}

	def generateMapperTestTemplate(Grammar g) '''package net.unicoen.mapper

import org.junit.Test
import static org.hamcrest.Matchers.*
import static org.junit.Assert.*

class «_name»MapperTest {
	val mapper = new «_name»Mapper(true)

	@Test
	def «_name»Test(){
		
	}

}
	'''

	def generateMapper(Grammar g) {
		val sb = new StringBuilder
		sb.append('''package net.unicoen.mapper

import java.io.FileInputStream
import org.antlr.v4.runtime.ANTLRInputStream
import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.tree.ParseTree
import net.unicoen.parser.«_name»Lexer
import net.unicoen.parser.«_name»Parser
import net.unicoen.parser.«_name»BaseVisitor
import net.unicoen.node.*

class «_name»Mapper extends «_name»BaseVisitor<Object> {
	var _isDebugMode = false

	new(boolean isDebugMode) {
		_isDebugMode = isDebugMode
	}

	def parseFile(String path) {
		val inputStream = new FileInputStream(path)
		try {
			parseCore(new ANTLRInputStream(inputStream))
		} finally {
			inputStream.close
		}
	}

	def parse(String code) {
		parseCore(new ANTLRInputStream(code))
	}

	def parseCore(CharStream chars) {
		val lexer = new «_name»Lexer(chars)
		val tokens = new CommonTokenStream(lexer)
		val parser = new «_name»Parser(tokens)
«IF g.rules.size > 0»		val tree = parser.«IF g.root != null»«g.root.root.name»«ELSE»«g.rules.get(0).name»«ENDIF»
		tree.visit
«ENDIF»	}

	override public visitChildren(RuleNode node) {
		val n = node.childCount;
		(0 ..< n).fold(defaultResult) [ acc, i |
			if (!node.shouldVisitNextChild(acc)) {
				acc
			} else {
				val c = node.getChild(i);
				val childResult = c.visit;
				acc.aggregateResult(childResult);
			}
		]
	}

	override public visit(ParseTree tree) {
		if (_isDebugMode) {
			if (!(tree instanceof ParserRuleContext)) {
				return visitTerminal(tree as TerminalNode)
			}
			val ruleName = «_name»Parser.ruleNames.get((tree as ParserRuleContext).ruleIndex)
			println("*** visit" + ruleName + " ***")
			println(tree.text)
			val ret = tree.accept(this)
			println("returned: " + ret)
			ret
		} else {
			tree.accept(this)
		}
	}''' + nl + nl)
		g.rules.forEach [
			if (it.type != null) {
				if (it.type.name.endsWith("Literal")) {
					sb.append(it.makeLiteralMethod)
				} else {
					sb.append(it.visitMethod)
				}
			}
		]
		sb.append('}' + nl)
		sb.toString
	}

	def toCamelCase(String str) {
		Character.toUpperCase(str.charAt(0)) + str.substring(1)
	}

	def dispatch visitMethod(ParserRule r) {
		val sb = new StringBuilder
		val name = r.type.name
		sb.append('''	override public visit«r.name.toCamelCase»(«_name»Parser.«r.name.toCamelCase»Context ctx) {''' +
			nl)
		if (name.startsWith("Uni")) {
			sb.append(r.makeMethodBody(Class.forName(packagePrefix + name)))
		} else if (name.startsWith("List")) {
			val itemClassName = name.substring(name.indexOf('<') + 1, name.indexOf('>'))
			sb.append(r.makeListMethodBody(itemClassName))
		} else if (name.equals("String")) {
			sb.append(r.makeStringMethodBody)
		} else {
			throw new RuntimeException("Unknown Class Name: " + name)
		}
		sb.append('''	}''' + nl + nl)
		sb
	}

	def makeCaseStatement(EObject obj, String type, String variable) '''				«_name»Parser.«obj.eAllContents.toIterable.
		filter(RuleRef).get(0).reference.name.toCamelCase»Context:
					ret.«variable» = it.visit as «type»'''

	def makeMethodBody(ParserRule r, Class<?> clz) {
		val sb = new StringBuilder
		println(r.type.name)
		sb.append('''		val ret = new «r.type.name»
		ctx.children.forEach [
			switch it {''' + nl)
		var list = r.eAllContents.toIterable.filter(ElementWithDollar)
		list.forEach [
			if (it.op == null) {
				return
			}
			if (it.op.equals("__merge")) {
				val fields = clz.fields
				val ruleName = it.eAllContents.toIterable.filter(RuleRef).get(0).reference.name.toCamelCase
				sb.append('''				«_name»Parser.«ruleName»Context: {''' + nl)
				sb.append('''					val child = it.visit as «r.type.name»''' + nl)
				fields.forEach [
					sb.append('''					if (child.«it.name» != null) {''' + nl)
					if (it.type.simpleName.endsWith("List")) {
						sb.append('''						if (ret.«it.name» != null) {''' + nl)
						sb.append('''							ret.«it.name» += child.«it.name»''' + nl)
						sb.append('''						} else {''' + nl)
						sb.append('''							ret.«it.name» = child.«it.name»''' + nl)
						sb.append('''						}''' + nl)
					} else {
						sb.append('''						ret.«it.name» = child.«it.name»''' + nl)
					}
					sb.append('''					}''' + nl)
				]
			}
			try {
				val field = clz.getField(it.op)
				val typeName = field.genericType.typeName
				sb.append(it.makeCaseStatement(typeName, it.op) + nl)
			} catch (NoSuchFieldException e) {
				return
			}
		]
		sb.append(
			'''			}
		]
		ret
		''')
		sb.toString
	}

	def getTypeName(Type type) {
		switch type {
			Class<?>:
				return type.name
			ParameterizedType: {
				val sb = new StringBuilder
				sb.append(type.typeName).append('<')
				var isFirst = true
				for (Type arg : type.actualTypeArguments) {
					if (!isFirst) {
						sb.append(',')
					}
					sb.append(arg.typeName)
				}
				sb.append('>')
				return sb.toString
			}
			default:
				throw new RuntimeException("Unknown type:" + type.toString)
		}
	}

	def makeListMethodBody(ParserRule r, String clz) {
		val sb = new StringBuilder
		sb.append(
			'''		val list = Lists.newArrayList
		if (ctx.children != null) {
			ctx.children.forEach [
				list += it.visit as «clz»
			]
		}
		list
		''')
		sb.toString
	}

	def dispatch visitMethod(LexerRule r) {
		r.type.name
	}

	def makeStringMethodBody(ParserRule r) {
		val sb = new StringBuilder
		sb.append('''		ctx.text''' + nl)
		sb.toString
	}

	def dispatch makeLiteralMethod(ParserRule r) {
		val sb = new StringBuilder
		val methodName = "visit" + r.name.toCamelCase
		sb.append('''	override public «methodName»(«_name»Parser.«r.name.toCamelCase»Context ctx) {''' + nl)
		sb.append('''		throw new RuntimeException("Unimplemented Method: «methodName»")''' + nl)
		sb.append('''	}''' + nl + nl)
		sb.toString
	}

	def dispatch makeLiteralMethod(LexerRule r) {
		r.visitMethod
	}

}

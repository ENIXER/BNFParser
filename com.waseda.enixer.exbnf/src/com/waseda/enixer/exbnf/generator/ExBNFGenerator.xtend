/*
 * generated by Xtext
 */
package com.waseda.enixer.exbnf.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import com.waseda.enixer.exbnf.exBNF.*
import org.eclipse.emf.ecore.EObject

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class ExBNFGenerator implements IGenerator {
	val nl = System.getProperty("line.separator")
	var name = new String

	override def doGenerate(Resource resource, IFileSystemAccess fsa) {
		val g4Generator = new ANTLRGrammarGenerator(fsa)
		resource.allContents.toIterable.filter(Grammar).forEach [
			name = it.name.toCamelCase
			g4Generator.generate(name, it);
			fsa.generateFile(name + "Mapper.xtend", it.generateMapper)
			fsa.generateFile(name + "MapperTest.xtend", it.generateMapperTestTemplate)
		]
	}

	def generateMapperTestTemplate(Grammar g) '''package net.unicoen.mapper

import org.junit.Test
import static org.hamcrest.Matchers.*
import static org.junit.Assert.*

class «name»MapperTest {
	val mapper = new «name»Mapper(true)

	@Test
	def «name»Test(){
		
	}

}
	'''

	def generateMapper(Grammar g) {
		val sb = new StringBuilder
		sb.append('''package net.unicoen.mapper

import java.io.FileInputStream
import org.antlr.v4.runtime.ANTLRInputStream
import org.antlr.v4.runtime.CharStream
import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.ParserRuleContext
import org.antlr.v4.runtime.tree.ParseTree
import net.unicoen.parser.«name»Lexer
import net.unicoen.parser.«name»Parser
import net.unicoen.parser.«name»BaseVisitor
import net.unicoen.node.UniBinOp
import net.unicoen.node.UniExpr
import net.unicoen.node.UniIntLiteral
import net.unicoen.node.UniDoubleLiteral

class «name»Mapper extends «name»BaseVisitor<Object> {
	var _isDebugMode = false

	new(boolean isDebugMode) {
		_isDebugMode = isDebugMode
	}

	def parseFile(String path) {
		val inputStream = new FileInputStream(path)
		try {
			parseCore(new ANTLRInputStream(inputStream))
		} finally {
			inputStream.close
		}
	}

	def parse(String code) {
		parseCore(new ANTLRInputStream(code))
	}

	def parseCore(CharStream chars) {
		val lexer = new «name»Lexer(chars)
		val tokens = new CommonTokenStream(lexer)
		val parser = new «name»Parser(tokens)
		val tree = parser.«g.rules.get(0).name»
		tree.visit
	}

	override public visitChildren(RuleNode node) {
		val n = node.childCount;
		(0 ..< n).fold(defaultResult) [ acc, i |
			if (!node.shouldVisitNextChild(acc)) {
				acc
			} else {
				val c = node.getChild(i);
				val childResult = c.visit;
				acc.aggregateResult(childResult);
			}
		]
	}

	override public visit(ParseTree tree) {
		if (_isDebugMode) {
			if (!(tree instanceof ParserRuleContext)) {
				return visitTerminal(tree as TerminalNode)
			}
			val ruleName = «name»Parser.ruleNames.get((tree as ParserRuleContext).ruleIndex)
			println("*** visit" + ruleName + " ***")
			println(tree.text)
			val ret = tree.accept(this)
			println("returned: " + ret)
			ret
		} else {
			tree.accept(this)
		}
	}''' + nl + nl)
		g.rules.forEach [
			if (it.type != null) {
				sb.append(it.visitMethod)
			}
		]
		sb.append('}' + nl)
		sb.toString
	}

	def toCamelCase(String str) {
		Character.toUpperCase(str.charAt(0)) + str.substring(1)
	}

	def dispatch visitMethod(ParserRule r) {
		val sb = new StringBuilder
		sb.append('''	override public visit«r.name.toCamelCase»(«name»Parser.«r.name.toCamelCase»Context ctx) {''' +
			nl)
		val type = r.type.name
		switch type {
			case "UniClassDec":
				sb.append(r.makeUniClassDecMethodBody)
			case "UniMethodDec":
				sb.append(r.makeUniMethodDecMethodBody)
			case "List<UniArg>":
				sb.append(r.makeListMethodBody("UniArg"))
			case "UniArg":
				sb.append(r.makeUniArgMethodBody)
			case "List<UniExpr>":
				sb.append(r.makeListMethodBody("UniExpr"))
			case "UniBlock":
				sb.append(r.makeUniBlockMethodBody)
			case "UniIntLiteral":
				sb.append(r.makeUniIntLiteralMethodBody)
			case "UniDoubleLiteral":
				sb.append(r.makeUniDoubleLiteralMethodBody)
			case "List<String>":
				sb.append(r.makeListMethodBody("String"))
			case "String":
				sb.append(r.makeStringMethodBody)
			default:
				sb.append(r.makeSuperMethodBody)
		}
		sb.append('''	}''' + nl + nl)
		sb
	}

	def makeCaseStatement(EObject obj, String type, String variable) '''				«name»Parser.«obj.eAllContents.toIterable.
		filter(RuleRef).get(0).reference.name.toCamelCase»Context:
					ret.«variable» = it.visit as «type»'''

	def makeUniClassDecMethodBody(ParserRule r) {
		val sb = new StringBuilder
		sb.append('''		val ret = new UniClassDec
		ret.members = Lists.newArrayList
		ctx.children.forEach [
			switch it {''' + nl)
		var list = r.eAllContents.toIterable.filter(ElementWithDollar)
		list.forEach [
			switch it.op {
				case "className":
					sb.append(it.makeCaseStatement("String", it.op) + nl)
				case "modifiers":
					sb.append(it.makeCaseStatement("List<String>", it.op) + nl)
				case "members":
					sb.append(it.makeCaseStatement("UniMemberDec", it.op) + nl)
				case null: {
					// do nothing
				}
			}
		]
		sb.append(
			'''			}
		]
		ret
		''')
		sb.toString
	}

	def makeListMethodBody(ParserRule r, String clz) {
		val sb = new StringBuilder
		sb.append(
			'''		val list = Lists.newArrayList
		if (ctx.children != null) {
			ctx.children.forEach [
				list += it.visit as «clz»
			]
		}
		list
		''')
		sb.toString
	}

	def makeUniMethodDecMethodBody(ParserRule r) {
		val sb = new StringBuilder
		sb.append('''		val ret = new UniMethodDec
		ctx.children.forEach [
			switch it {''' + nl)
		r.eAllContents.toIterable.filter(ElementWithDollar).forEach [
			switch it.op {
				case "returnType":
					sb.append(it.makeCaseStatement("String", it.op) + nl)
				case "methodName":
					sb.append(it.makeCaseStatement("String", it.op) + nl)
				case "block":
					sb.append(it.makeCaseStatement("UniBlock", it.op) + nl)
				case "modifiers":
					sb.append(it.makeCaseStatement("List<String>", it.op) + nl)
				case "args":
					sb.append(it.makeCaseStatement("List<UniArg>", it.op) + nl)
				case null: {
					// do nothing
				}
			}
		]
		sb.append(
			'''			}
		]
		ret
		''')
		sb.toString
	}

	def makeUniArgMethodBody(ParserRule r) {
		val sb = new StringBuilder
		sb.append('''		val ret = new UniArg
		ctx.children.forEach [
			switch it {''' + nl)
		r.eAllContents.toIterable.filter(ElementWithDollar).forEach [
			switch it.op {
				case "type":
					sb.append(it.makeCaseStatement("String", it.op) + nl)
				case "name":
					sb.append(it.makeCaseStatement("String", it.op) + nl)
				case null: {
					// do nothing
				}
			}
		]
		sb.append(
			'''			}
		]
		ret
		''')
		sb.toString
	}

	def makeUniBlockMethodBody(ParserRule r) {
		val sb = new StringBuilder
		sb.append('''		val ret = Lists.newArrayList
		ctx.children.forEach [
			switch it {''' + nl)
		r.eAllContents.toIterable.filter(ElementWithDollar).forEach [
			switch it.op {
				case "body":
					sb.append(it.makeCaseStatement("UniExpr", it.op) + nl)
				case null: {
					// do nothing
				}
			}
		]
		sb.append('''			}
		]
		new UniBlock(ret)''' + nl)
		sb.toString
	}

	def dispatch visitMethod(LexerRule r) {
		var name = r.type.name
		name
	}

	def makeUniIntLiteralMethodBody(ParserRule r) {
		var sb = new StringBuilder
		sb.append('''		new UniIntLiteral(Integer.parseInt(ctx.text))''' + nl)
		sb
	}

	def makeUniDoubleLiteralMethodBody(ParserRule r) {
		var sb = new StringBuilder
		sb.append('''		new UniDoubleLiteral(Double.parseDouble(ctx.text))''' + nl)
		sb
	}

	def makeStringMethodBody(ParserRule r) {
		var sb = new StringBuilder
		sb.append('''		ctx.text''' + nl)
		sb
	}

	def makeSuperMethodBody(ParserRule r) {
		var sb = new StringBuilder
		sb.append('''		// Return type «r.type.name» is not supported.''' + nl)
		sb.append('''		super.visit«r.name.toCamelCase»(ctx)''' + nl)
		sb
	}
}

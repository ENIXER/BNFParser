/**
 * generated by Xtext
 */
package org.xtext.example.mydsl.generator;

import com.google.common.collect.Iterables;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.IFileSystemAccess;
import org.eclipse.xtext.generator.IGenerator;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.StringExtensions;
import org.xtext.example.mydsl.myDsl.Element;
import org.xtext.example.mydsl.myDsl.Expression;
import org.xtext.example.mydsl.myDsl.Grammar;
import org.xtext.example.mydsl.myDsl.KeyConstr;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.Rule;
import org.xtext.example.mydsl.myDsl.RuleCall;
import org.xtext.example.mydsl.myDsl.Term;

@SuppressWarnings("all")
public class MyDslGenerator implements IGenerator {
  public void doGenerate(final Resource resource, final IFileSystemAccess fsa) {
    TreeIterator<EObject> _allContents = resource.getAllContents();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(_allContents);
    Iterable<Model> _filter = Iterables.<Model>filter(_iterable, Model.class);
    for (final Model m : _filter) {
      {
        Grammar _gram = m.getGram();
        String _gname = _gram.getGname();
        String _upperCaseOnlyFirst = this.toUpperCaseOnlyFirst(_gname);
        String _plus = (_upperCaseOnlyFirst + ".g4");
        CharSequence _compile = this.compile(m);
        fsa.generateFile(_plus, _compile);
        Grammar _gram_1 = m.getGram();
        String _gname_1 = _gram_1.getGname();
        String _upperCaseOnlyFirst_1 = this.toUpperCaseOnlyFirst(_gname_1);
        String _plus_1 = ("CountElements" + _upperCaseOnlyFirst_1);
        String _plus_2 = (_plus_1 + ".dat");
        CharSequence _exportExtractElements = this.exportExtractElements(m);
        fsa.generateFile(_plus_2, _exportExtractElements);
        Grammar _gram_2 = m.getGram();
        String _gname_2 = _gram_2.getGname();
        String _upperCaseOnlyFirst_2 = this.toUpperCaseOnlyFirst(_gname_2);
        String _plus_3 = ("Main" + _upperCaseOnlyFirst_2);
        String _plus_4 = (_plus_3 + ".java");
        CharSequence _mainCompile = this.mainCompile(m);
        fsa.generateFile(_plus_4, _mainCompile);
        Grammar _gram_3 = m.getGram();
        String _gname_3 = _gram_3.getGname();
        String _upperCaseOnlyFirst_3 = this.toUpperCaseOnlyFirst(_gname_3);
        String _plus_5 = (_upperCaseOnlyFirst_3 + "Extractor.java");
        CharSequence _listenerCompile = this.listenerCompile(m);
        fsa.generateFile(_plus_5, _listenerCompile);
      }
    }
  }
  
  public CharSequence compile(final Model m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("grammar ");
    Grammar _gram = m.getGram();
    String _gname = _gram.getGname();
    String _upperCaseOnlyFirst = this.toUpperCaseOnlyFirst(_gname);
    _builder.append(_upperCaseOnlyFirst, "");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    {
      EList<Rule> _rules = m.getRules();
      for(final Rule r : _rules) {
        {
          String _name = r.getName();
          char _charAt = _name.charAt(0);
          boolean _isLowerCase = Character.isLowerCase(_charAt);
          if (_isLowerCase) {
            CharSequence _acompile = this.acompile(r);
            _builder.append(_acompile, "");
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    {
      EList<Rule> _rules_1 = m.getRules();
      for(final Rule r_1 : _rules_1) {
        {
          String _name_1 = r_1.getName();
          char _charAt_1 = _name_1.charAt(0);
          boolean _isUpperCase = Character.isUpperCase(_charAt_1);
          if (_isUpperCase) {
            CharSequence _bcompile = this.bcompile(r_1);
            _builder.append(_bcompile, "");
          }
        }
      }
    }
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("Whitespace:");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("[ \\r\\n\\t] -> skip;");
    return _builder;
  }
  
  public CharSequence acompile(final Rule r) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = r.getName();
    _builder.append(_name, "");
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    Expression _expression = r.getExpression();
    CharSequence _acompile = this.acompile(_expression);
    _builder.append(_acompile, "	");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence acompile(final Expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<Element> _elements = exp.getElements();
      for(final Element ele : _elements) {
        {
          EList<Term> _terms = ele.getTerms();
          for(final Term t : _terms) {
            {
              EList<RuleCall> _rCall = t.getRCall();
              for(final RuleCall r : _rCall) {
                {
                  boolean _and = false;
                  EList<Element> _elements_1 = exp.getElements();
                  Element _head = IterableExtensions.<Element>head(_elements_1);
                  boolean _equals = _head.equals(ele);
                  boolean _not = (!_equals);
                  if (!_not) {
                    _and = false;
                  } else {
                    EList<Term> _terms_1 = ele.getTerms();
                    Term _head_1 = IterableExtensions.<Term>head(_terms_1);
                    boolean _equals_1 = _head_1.equals(t);
                    _and = (_not && _equals_1);
                  }
                  if (_and) {
                    _builder.append("| ");
                  }
                }
                Rule _ref = r.getRef();
                String _name = _ref.getName();
                _builder.append(_name, "");
                _builder.append(" ");
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence bcompile(final Rule r) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = r.getName();
    _builder.append(_name, "");
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    Expression _expression = r.getExpression();
    CharSequence _bcompile = this.bcompile(_expression);
    _builder.append(_bcompile, "	");
    _builder.append(";");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public CharSequence bcompile(final Expression exp) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<Element> _elements = exp.getElements();
      for(final Element ele : _elements) {
        {
          EList<Term> _terms = ele.getTerms();
          for(final Term t : _terms) {
            {
              EList<KeyConstr> _kConstr = t.getKConstr();
              for(final KeyConstr k : _kConstr) {
                {
                  boolean _and = false;
                  EList<Element> _elements_1 = exp.getElements();
                  Element _head = IterableExtensions.<Element>head(_elements_1);
                  boolean _equals = _head.equals(ele);
                  boolean _not = (!_equals);
                  if (!_not) {
                    _and = false;
                  } else {
                    EList<Term> _terms_1 = ele.getTerms();
                    Term _head_1 = IterableExtensions.<Term>head(_terms_1);
                    boolean _equals_1 = _head_1.equals(t);
                    _and = (_not && _equals_1);
                  }
                  if (_and) {
                    _builder.append("| ");
                  }
                }
                _builder.append("\'");
                String _sChar = k.getSChar();
                _builder.append(_sChar, "");
                _builder.append("\' ");
                {
                  String _eChar = k.getEChar();
                  boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_eChar);
                  boolean _not_1 = (!_isNullOrEmpty);
                  if (_not_1) {
                    _builder.append(".. \'");
                    String _eChar_1 = k.getEChar();
                    _builder.append(_eChar_1, "");
                    _builder.append("\' ");
                  }
                }
              }
            }
          }
        }
      }
    }
    return _builder;
  }
  
  public CharSequence exportExtractElements(final Model m) {
    StringConcatenation _builder = new StringConcatenation();
    {
      EList<Rule> _rules = m.getRules();
      for(final Rule r : _rules) {
        {
          String _count = r.getCount();
          boolean _isNullOrEmpty = StringExtensions.isNullOrEmpty(_count);
          boolean _not = (!_isNullOrEmpty);
          if (_not) {
            String _name = r.getName();
            _builder.append(_name, "");
            _builder.newLineIfNotEmpty();
          }
        }
      }
    }
    return _builder;
  }
  
  public String toUpperCaseOnlyFirst(final String s) {
    String _substring = s.substring(0, 1);
    String _upperCase = _substring.toUpperCase();
    String _substring_1 = s.substring(1);
    String _lowerCase = _substring_1.toLowerCase();
    String _plus = (_upperCase + _lowerCase);
    return _plus;
  }
  
  public CharSequence mainCompile(final Model m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package com.sample;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.util.Arrays;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.ANTLRInputStream;");
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.CharStream;");
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.CommonTokenStream;");
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.ParserRuleContext;");
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.tree.ParseTreeWalker;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import parser.");
    Grammar _gram = m.getGram();
    String _gname = _gram.getGname();
    String _upperCaseOnlyFirst = this.toUpperCaseOnlyFirst(_gname);
    _builder.append(_upperCaseOnlyFirst, "");
    _builder.append("Lexer;");
    _builder.newLineIfNotEmpty();
    _builder.append("import parser.");
    Grammar _gram_1 = m.getGram();
    String _gname_1 = _gram_1.getGname();
    String _upperCaseOnlyFirst_1 = this.toUpperCaseOnlyFirst(_gname_1);
    _builder.append(_upperCaseOnlyFirst_1, "");
    _builder.append("Parser;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public class Main");
    Grammar _gram_2 = m.getGram();
    String _gname_2 = _gram_2.getGname();
    String _upperCaseOnlyFirst_2 = this.toUpperCaseOnlyFirst(_gname_2);
    _builder.append(_upperCaseOnlyFirst_2, "");
    _builder.append(" {");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("/**");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("* @param args");
    _builder.newLine();
    _builder.append("\t ");
    _builder.append("*/");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public static void main(String[] args) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("String code = \"int m(v){int a = 0; if(i==0) a++;}\";");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("CharStream input = new ANTLRInputStream(code);");
    _builder.newLine();
    _builder.append("\t\t");
    Grammar _gram_3 = m.getGram();
    String _gname_3 = _gram_3.getGname();
    String _upperCaseOnlyFirst_3 = this.toUpperCaseOnlyFirst(_gname_3);
    _builder.append(_upperCaseOnlyFirst_3, "		");
    _builder.append("Lexer lexer = new ");
    Grammar _gram_4 = m.getGram();
    String _gname_4 = _gram_4.getGname();
    String _upperCaseOnlyFirst_4 = this.toUpperCaseOnlyFirst(_gname_4);
    _builder.append(_upperCaseOnlyFirst_4, "		");
    _builder.append("Lexer(input);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("CommonTokenStream tokens = new CommonTokenStream(lexer);");
    _builder.newLine();
    _builder.append("\t\t");
    Grammar _gram_5 = m.getGram();
    String _gname_5 = _gram_5.getGname();
    String _upperCaseOnlyFirst_5 = this.toUpperCaseOnlyFirst(_gname_5);
    _builder.append(_upperCaseOnlyFirst_5, "		");
    _builder.append("Parser parser = new ");
    Grammar _gram_6 = m.getGram();
    String _gname_6 = _gram_6.getGname();
    String _upperCaseOnlyFirst_6 = this.toUpperCaseOnlyFirst(_gname_6);
    _builder.append(_upperCaseOnlyFirst_6, "		");
    _builder.append("Parser(tokens);");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("ParseTreeWalker walker = new ParseTreeWalker();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    Grammar _gram_7 = m.getGram();
    String _gname_7 = _gram_7.getGname();
    String _upperCaseOnlyFirst_7 = this.toUpperCaseOnlyFirst(_gname_7);
    _builder.append(_upperCaseOnlyFirst_7, "		");
    _builder.append("Extractor extractor = new ");
    Grammar _gram_8 = m.getGram();
    String _gname_8 = _gram_8.getGname();
    String _upperCaseOnlyFirst_8 = this.toUpperCaseOnlyFirst(_gname_8);
    _builder.append(_upperCaseOnlyFirst_8, "		");
    _builder.append("Extractor(parser);");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Parse code and generate a parse tree");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("ParserRuleContext tree = parser.translation_unit();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Scan the parse tree");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("walker.walk(myListener, tree);");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Show PM counts");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("myListener.showTokenCounts();");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("// Show Complexity");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("myListener.showCyclomaticComplexity();");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }
  
  public CharSequence listenerCompile(final Model m) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("package com.sample;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import java.io.*;");
    _builder.newLine();
    _builder.append("import java.util.*;");
    _builder.newLine();
    _builder.append("import java.util.Map.Entry;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.ParserRuleContext;");
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.Token;");
    _builder.newLine();
    _builder.append("import org.antlr.v4.runtime.tree.TerminalNode;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("import parser.");
    Grammar _gram = m.getGram();
    String _gname = _gram.getGname();
    String _upperCaseOnlyFirst = this.toUpperCaseOnlyFirst(_gname);
    _builder.append(_upperCaseOnlyFirst, "");
    _builder.append("BaseListener;");
    _builder.newLineIfNotEmpty();
    _builder.append("import parser.");
    Grammar _gram_1 = m.getGram();
    String _gname_1 = _gram_1.getGname();
    String _upperCaseOnlyFirst_1 = this.toUpperCaseOnlyFirst(_gname_1);
    _builder.append(_upperCaseOnlyFirst_1, "");
    _builder.append("Lexer;");
    _builder.newLineIfNotEmpty();
    _builder.append("import parser.");
    Grammar _gram_2 = m.getGram();
    String _gname_2 = _gram_2.getGname();
    String _upperCaseOnlyFirst_2 = this.toUpperCaseOnlyFirst(_gname_2);
    _builder.append(_upperCaseOnlyFirst_2, "");
    _builder.append("Parser;");
    _builder.newLineIfNotEmpty();
    _builder.newLine();
    _builder.append("public class ");
    Grammar _gram_3 = m.getGram();
    String _gname_3 = _gram_3.getGname();
    String _upperCaseOnlyFirst_3 = this.toUpperCaseOnlyFirst(_gname_3);
    _builder.append(_upperCaseOnlyFirst_3, "");
    _builder.append("Extractor extends ");
    Grammar _gram_4 = m.getGram();
    String _gname_4 = _gram_4.getGname();
    String _upperCaseOnlyFirst_4 = this.toUpperCaseOnlyFirst(_gname_4);
    _builder.append(_upperCaseOnlyFirst_4, "");
    _builder.append("BaseListener {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("private ");
    Grammar _gram_5 = m.getGram();
    String _gname_5 = _gram_5.getGname();
    String _upperCaseOnlyFirst_5 = this.toUpperCaseOnlyFirst(_gname_5);
    _builder.append(_upperCaseOnlyFirst_5, "	");
    _builder.append("Parser _parser;");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("private HashMap<String, Integer> _map;");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("private Set<String> extractElementSet;");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public ");
    Grammar _gram_6 = m.getGram();
    String _gname_6 = _gram_6.getGname();
    String _upperCaseOnlyFirst_6 = this.toUpperCaseOnlyFirst(_gname_6);
    _builder.append(_upperCaseOnlyFirst_6, "	");
    _builder.append("Extractor(");
    Grammar _gram_7 = m.getGram();
    String _gname_7 = _gram_7.getGname();
    String _upperCaseOnlyFirst_7 = this.toUpperCaseOnlyFirst(_gname_7);
    _builder.append(_upperCaseOnlyFirst_7, "	");
    _builder.append("Parser parser) {");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("_parser = parser;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("_map = new HashMap<String, Integer>();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("extractElementSet = new HashSet<String>();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("File countElementsFile = new File(\"dat\\\\CountElements");
    Grammar _gram_8 = m.getGram();
    String _gname_8 = _gram_8.getGname();
    String _upperCaseOnlyFirst_8 = this.toUpperCaseOnlyFirst(_gname_8);
    _builder.append(_upperCaseOnlyFirst_8, "		");
    _builder.append(".dat\");");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("try {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Scanner scanner = new Scanner(countElementsFile);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("while (scanner.hasNext()) {");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("String element = scanner.next();");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("extractElementSet.add(element);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("scanner.close();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("} catch (FileNotFoundException e) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("e.printStackTrace();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void showTokenCounts() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("System.out.println(\"*** showTokenCounts ***\");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (Entry<String, Integer> nameAndCount : _map.entrySet()) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("String name = nameAndCount.getKey();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("int count = nameAndCount.getValue();");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("System.out.println(name + \": \" + count);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void showCyclomaticComplexity() {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("System.out.println(\"*** showCyclomaticComplexity ***\");");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("int result = 1;");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for (Entry<String, Integer> nameAndCount : _map.entrySet()) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("result += nameAndCount.getValue();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("System.out.println(\"Cyclomatic Complexity : \" + result);");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@Override");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void visitTerminal(TerminalNode node) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("Token token = node.getSymbol();");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("String tokenName = ");
    Grammar _gram_9 = m.getGram();
    String _gname_9 = _gram_9.getGname();
    String _upperCaseOnlyFirst_9 = this.toUpperCaseOnlyFirst(_gname_9);
    _builder.append(_upperCaseOnlyFirst_9, "		");
    _builder.append("Lexer.ruleNames[token.getType() - 1];");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("if (extractElementSet.contains(tokenName)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("System.out.println(\"*** visitTerminal ***\");");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("System.out.println(tokenName + \": \" + token.getText());");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("// Count tokens");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Integer value = _map.get(tokenName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("value = value == null ? 0 : value;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("_map.put(tokenName, value + 1);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t");
    _builder.append("@Override");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("public void enterEveryRule(ParserRuleContext ctx) {");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("String ruleName = ");
    Grammar _gram_10 = m.getGram();
    String _gname_10 = _gram_10.getGname();
    String _upperCaseOnlyFirst_10 = this.toUpperCaseOnlyFirst(_gname_10);
    _builder.append(_upperCaseOnlyFirst_10, "		");
    _builder.append("Parser.ruleNames[ctx.getRuleIndex()];");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t");
    _builder.append("if (extractElementSet.contains(ruleName)) {");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("System.out.println(\"*** visitRule ***\");");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("System.out.println(ruleName + \": \" + ctx.getText());");
    _builder.newLine();
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("Integer value = _map.get(ruleName);");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("value = value == null ? 0 : value;");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("_map.put(ruleName, value + 1);");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("}");
    _builder.newLine();
    _builder.append("}");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }
}

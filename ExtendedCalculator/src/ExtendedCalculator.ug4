grammar ExtendedCalculator;
root compilationUnit;
@ header {
package net.unicoen.parser;
}

compilationUnit => UniClassDec:
	( classNameDeclaration$MERGE )? expressionList$members;

classNameDeclaration:
	'class' Identifier$className ';';

expressionList:
	( expression$ADD )*;

expression:
	variableDeclaration
	| functionDeclaration;

addSubExpression => UniBinOp:
	mulDivExpression$RETURN
	| addSubExpression$left PLUS$operator mulDivExpression$right
	| addSubExpression$left MINUS$operator mulDivExpression$right;

mulDivExpression => UniBinOp:
	factor$RETURN
	| mulDivExpression$left MUL$operator factor$right
	| mulDivExpression$left DIV$operator factor$right
	| mulDivExpression$left MOD$operator factor$right;

factor:
	functionCall
	| variableAccess
	| literal
	| nestedExpression;

nestedExpression:
	'(' addSubExpression$RETURN ')';

functionCall => UniMethodCall:
	functionName$methodName '(' argumentList?$args ')';

functionName => String:
	Identifier;

argumentList:
	argument$ADD ( ',' argument$ADD )*;

argument:
	addSubExpression;

variableAccess => UniFieldAccess:
	variableName$fieldName;

literal:
	integerLiteral
	| floatingPointLiteral;

variableDeclaration => UniFieldDec:
	variableName$name '=' addSubExpression$value ';';

variableName => String:
	Identifier;

functionDeclaration => UniMethodDec:
	functionName$methodName '(' parameterList?$args ')' '=' methodBody$block;

methodBody => UniBlock:
	'{' addSubExpressionList$body '}';

addSubExpressionList:
	addSubExpression$ADD;

parameterList:
	parameter$ADD ( ',' parameter$ADD )*;

parameter => UniArg:
	variableName$name;

integerLiteral => UniIntLiteral:
	IntegerLiteral$value;

floatingPointLiteral => UniDoubleLiteral:
	FloatingPointLiteral$value;

Identifier:
	[a-zA-Z_]+;

IntegerLiteral:
	DecimalNumeral;

fragment DecimalNumeral:
	'0'
	| NonZeroDigit Digits?;

fragment Digits:
	Digit*;

fragment Digit:
	'0'
	| NonZeroDigit;

fragment NonZeroDigit:
	[1-9];

FloatingPointLiteral:
	Digits '.' Digits? ExponentPart? FloatTypeSuffix?
	| '.' Digits ExponentPart? FloatTypeSuffix?
	| Digits ExponentPart FloatTypeSuffix?
	| Digits FloatTypeSuffix;

fragment ExponentPart:
	ExponentIndicator SignedInteger;

fragment ExponentIndicator:
	[eE];

fragment SignedInteger:
	Sign? Digits;

fragment Sign:
	[+-];

fragment FloatTypeSuffix:
	[fFdD];

fragment BinaryExponent:
	BinaryExponentIndicator SignedInteger;

fragment BinaryExponentIndicator:
	[pP];

PLUS:
	'+';

MINUS:
	'-';

MUL:
	'*';

DIV:
	'/';

MOD:
	'%';

WS:
	[ \t\r\n\u000C]+ -> skip;

COMMENT:
	'/*' .* ? '*/' -> skip;

LINE_COMMENT:
	'//' ~ [\r\n]* -> skip;
	
